<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebAuthn PRF → Ethereum address demo</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 1.5rem; max-width: 720px; }
    button { margin: .5rem 0; padding: .5rem 1rem; }
    pre { background:#f6f8fa; padding: .75rem; border-radius:6px; overflow:auto; }
  </style>
</head>
<body>
  <h1>WebAuthn PRF → Ethereum address (demo)</h1>
  <p>Register a passkey with PRF, then derive a deterministic Ethereum address from it.</p>

  <button id="registerBtn">Register (enable PRF)</button>
  <button id="deriveBtn">Derive ETH address</button>

  <h3>Output</h3>
  <pre id="out">No output yet.</pre>

  <!-- Ethers.js CDN (v6). Use the version you prefer in production -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>

<script>
const outEl = document.getElementById('out');
const out = (v) => { outEl.textContent = typeof v === 'string' ? v : JSON.stringify(v, null, 2); };

// helpers
const randomBytes = (n) => crypto.getRandomValues(new Uint8Array(n));
const b64 = (buf) => {
  const s = String.fromCharCode(...new Uint8Array(buf));
  return btoa(s);
};
const unb64 = (s) => {
  const bin = atob(s);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
  return arr.buffer;
};
const bufToHex = (buf) => Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
const SECP256K1_N = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");

// register enabling PRF
async function registerWithPrf() {
  try {
    const challenge = randomBytes(32);
    const userId = randomBytes(16);

    const publicKey = {
      challenge,
      rp: { name: "Example (demo)", id: location.hostname },
      user: { id: userId, name: "demo-user@example.com", displayName: "Demo User" },
      pubKeyCredParams: [{ alg: -7, type: "public-key" }],
      extensions: { prf: {} },
      timeout: 60000,
      attestation: "none"
    };

    const cred = await navigator.credentials.create({ publicKey });
    if (!cred) throw new Error("Credential creation failed or dismissed");
    localStorage.setItem('webauthn-credential-id', b64(cred.rawId));
    out("Registered credential and enabled PRF. Saved credential id locally.");
  } catch (err) {
    out("Register error: " + (err && err.message || err));
    console.error(err);
  }
}

// derive PRF + HKDF -> 32 bytes -> Ethereum address
async function deriveEthAddress() {
  try {
    const stored = localStorage.getItem('webauthn-credential-id');
    if (!stored) throw new Error("No credential id found. Run Register first.");
    const credIdBuf = unb64(stored);

    const challenge = randomBytes(32);
    const infoLabel = new TextEncoder().encode("com.example.eth-key-v1");

    const publicKey = {
      challenge,
      allowCredentials: [{ id: credIdBuf, type: "public-key" }],
      rpId: location.hostname,
      timeout: 60000,
      userVerification: "preferred",
      extensions: {
        prf: {
          eval: {
            first: infoLabel
          }
        }
      }
    };

    const assertion = await navigator.credentials.get({ publicKey });
    if (!assertion) throw new Error("Assertion failed or dismissed");

    const ext = assertion.getClientExtensionResults && assertion.getClientExtensionResults();
    if (!ext || !ext.prf || !ext.prf.results || !ext.prf.results.first) {
      throw new Error("PRF result missing — UA/authenticator may not support PRF for this credential.");
    }

    const prfOutput = ext.prf.results.first; // ArrayBuffer or Uint8Array

    // HKDF-SHA256 -> 32 bytes, with deterministic retry counter appended to info if needed
    const ethPrivHex = await prfToValidEthPrivKey(prfOutput, infoLabel);

    // convert to ethers Wallet and compute address
    // ethers expects a 0x-prefixed private key hex string
    const priv0x = "0x" + ethPrivHex;
    const wallet = new ethers.Wallet(priv0x); // ethers v6
    out({
      privateKey: priv0x,
      address: wallet.address
    });
  } catch (err) {
    out("Derive error: " + (err && err.message || err));
    console.error(err);
  }
}

async function prfToValidEthPrivKey(prfBuf, infoLabel) {
  const baseKey = await crypto.subtle.importKey("raw", prfBuf, "HKDF", false, ["deriveBits"]);
  const salt = new Uint8Array(32); // zeros — keep deterministic across derivations

  for (let counter = 0; counter < 16; ++counter) {
    const info = new Uint8Array(infoLabel.byteLength + 1);
    info.set(new Uint8Array(infoLabel), 0);
    info[infoLabel.byteLength] = counter;

    const bits = await crypto.subtle.deriveBits(
      { name: "HKDF", hash: "SHA-256", salt, info },
      baseKey,
      8 * 32
    );
    const privBytes = new Uint8Array(bits);
    const hex = bufToHex(privBytes.buffer);

    // convert to BigInt and check range
    let n = 0n;
    for (let i = 0; i < privBytes.length; ++i) n = (n << 8n) + BigInt(privBytes[i]);
    if (n === 0n) continue;
    if (n >= SECP256K1_N) continue;
    return hex;
  }
  throw new Error("Failed to derive valid secp256k1 private key after retries");
}

document.getElementById('registerBtn').addEventListener('click', registerWithPrf);
document.getElementById('deriveBtn').addEventListener('click', deriveEthAddress);

out("Ready. Click Register to enable PRF on a credential, then Derive to get an ETH private key and address.");
</script>
</body>
</html>
