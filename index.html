<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebAuthn PRF â†’ Ethereum address demo (Resident Keys)</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding: 1.5rem; max-width: 720px; }
    button { margin: .5rem 0; padding: .5rem 1rem; }
    pre { background:#f6f8fa; padding: .75rem; border-radius:6px; overflow:auto; }
  </style>
</head>
<body>
  <h1>WebAuthn PRF â†’ Ethereum address (resident keys)</h1>
  <p>This version uses discoverable credentials (resident keys).</p>

  <button id="registerBtn">Register Passkey (PRF + Resident Key)</button>
  <br><br>

  <button id="deriveBtn">Derive ETH address (auto-pick passkey)</button>

  <h3>Output</h3>
  <pre id="out">No output yet.</pre>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6/dist/ethers.umd.min.js"></script>

<script>
const outEl = document.getElementById('out');
const out = (v) => { outEl.textContent = typeof v === 'string' ? v : JSON.stringify(v, null, 2); };

// helpers
const randomBytes = (n) => crypto.getRandomValues(new Uint8Array(n));
const bufToHex = (buf) => Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
const SECP256K1_N = BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141");

//
// 1. REGISTER â€” create resident passkey with PRF
//
async function registerWithPrf() {
  try {
    const challenge = randomBytes(32);

    const publicKey = {
      challenge,
      rp: { name: "Example (resident demo)", id: location.hostname },
      user: {
        id: randomBytes(16),
        name: "demo@example.com",
        displayName: "Demo User"
      },

      pubKeyCredParams: [{ alg: -7, type: "public-key" }],

      // ðŸ”¥ Require resident key (discoverable credential)
      authenticatorSelection: {
        residentKey: "required",
        requireResidentKey: true
      },

      extensions: { prf: {} },

      timeout: 60000,
      attestation: "none"
    };

    const cred = await navigator.credentials.create({ publicKey });
    if (!cred) throw new Error("Credential creation failed or dismissed");

    const rawIdHex = bufToHex(cred.rawId);

    out({
      message: "Registered resident passkey with PRF.",
      credentialId_hex: rawIdHex,
      note: "No need to store credential ID â€” authenticator will discover it."
    });

  } catch (err) {
    out("Register error: " + err.message);
    console.error(err);
  }
}

//
// 2. DERIVE â€” PRF via discoverable credential
//
async function deriveEthAddress() {
  try {
    const challenge = randomBytes(32);
    const infoLabel = new TextEncoder().encode("com.example.eth-key-v1");

    // ðŸ”¥ Notice: NO allowCredentials â€” so browser triggers account discovery UI
    const publicKey = {
      challenge,
      rpId: location.hostname,
      timeout: 60000,
      userVerification: "preferred",
      extensions: {
        prf: {
          eval: {
            first: infoLabel
          }
        }
      }
    };

    const assertion = await navigator.credentials.get({ publicKey });
    if (!assertion) throw new Error("Assertion failed or dismissed");

    const ext = assertion.getClientExtensionResults?.();
    if (!ext || !ext.prf || !ext.prf.results || !ext.prf.results.first)
      throw new Error("PRF result missing â€” authenticator may not support PRF.");

    const prfOutput = ext.prf.results.first;

    const ethPrivHex = await prfToValidEthPrivKey(prfOutput, infoLabel);
    const wallet = new ethers.Wallet("0x" + ethPrivHex);

    out({
      derivedUsing: "resident credential",
      privateKey: wallet.privateKey,
      address: wallet.address
    });

  } catch (err) {
    out("Derive error: " + err.message);
    console.error(err);
  }
}

//
// Convert PRF output â†’ valid secp256k1 private key
//
async function prfToValidEthPrivKey(prfBuf, infoLabel) {
  const baseKey = await crypto.subtle.importKey("raw", prfBuf, "HKDF", false, ["deriveBits"]);
  const salt = new Uint8Array(32);

  for (let counter = 0; counter < 16; ++counter) {
    const info = new Uint8Array(infoLabel.byteLength + 1);
    info.set(new Uint8Array(infoLabel), 0);
    info[infoLabel.byteLength] = counter;

    const bits = await crypto.subtle.deriveBits(
      { name: "HKDF", hash: "SHA-256", salt, info },
      baseKey,
      8 * 32
    );
    const privBytes = new Uint8Array(bits);

    let n = 0n;
    for (let b of privBytes) n = (n << 8n) + BigInt(b);

    if (n > 0n && n < SECP256K1_N) return bufToHex(privBytes.buffer);
  }
  throw new Error("Failed to derive valid privkey after retries");
}

document.getElementById('registerBtn').addEventListener('click', registerWithPrf);
document.getElementById('deriveBtn').addEventListener('click', deriveEthAddress);

out("Ready. Register a resident passkey and derive the same Ethereum key across synced devices.");
</script>
</body>
</html>
